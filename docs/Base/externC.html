

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh-CN" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh-CN" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>extern “C” 用法 &mdash; Template 1 文档</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="C++ 头文件" href="../Code/README.html" />
    <link rel="prev" title="cast" href="cast.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Template
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">简介</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../README.html">简介</a></li>
</ul>
<p class="caption"><span class="caption-text">基础</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="README.html">base</a></li>
<li class="toctree-l1"><a class="reference internal" href="cast.html">cast</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">extern “C” 用法</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id1">extern “C”的含义</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#extern">extern关键字</a></li>
<li class="toctree-l3"><a class="reference internal" href="#extern-c-c">被extern “C”修饰的变量和函数是按照C语言方式编译和链接的</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">头文件</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Code/README.html">C++ 头文件</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Code/algorithm.html">algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Code/array.html">array</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Code/cmath.html">cmath</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Code/map.html">map</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Code/random.html">random</a></li>
</ul>
<p class="caption"><span class="caption-text">技术储备</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Technical/README.html">README</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Technical/map.html">map</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Technical/sstream.html">sstream</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Technical/string.html">string</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Technical/sys.html">sys</a></li>
</ul>
<p class="caption"><span class="caption-text">外部库</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../ExternalLibrary/README.html">外部库的调用</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ExternalLibrary/fftw3.html">fftw3</a></li>
</ul>
<p class="caption"><span class="caption-text">规范</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Experience/README.html">规范</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Experience/ReturnNewline.html">回车符和换行符</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Template</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>extern “C” 用法</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/Base/externC.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <!-- externC.md --- 
;; 
;; Description: 
;; Author: Hongyi Wu(吴鸿毅)
;; Email: wuhongyi@qq.com 
;; Created: 六 5月 13 11:04:43 2017 (+0800)
;; Last-Updated: 六 5月 13 12:02:31 2017 (+0800)
;;           By: Hongyi Wu(吴鸿毅)
;;     Update #: 2
;; URL: http://wuhongyi.cn --><div class="section" id="extern-c">
<h1>extern “C” 用法<a class="headerlink" href="#extern-c" title="永久链接至标题">¶</a></h1>
<p>C++保留了一部分过程式语言的特点，因而它可以定义不属于任何类的全局变量和函数。但是，C++毕竟是一种面向对象的程序设计语言，为了支持函数的重载，C++对全局函数的处理方式与C有明显的不同。
extern “C”的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern “C”后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般之包括函数名。
比如说你用C 开发了一个DLL 库，为了能够让C ++语言也能够调用你的DLL输出(Export)的函数，你需要用extern “C”来强制编译器不要修改你的函数名。</p>
<hr class="docutils" />
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifndef __INCvxWorksh  </span><span class="cm">/*防止该头文件被重复引用*/</span><span class="cp"></span>
<span class="cp">#define __INCvxWorksh</span>

<span class="cp">#ifdef __cplusplus    </span><span class="c1">//__cplusplus是cpp中自定义的一个宏</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="p">{</span>          <span class="c1">//告诉编译器，这部分代码按C语言的格式进行编译，而不是C++的</span>
<span class="cp">#endif</span>

    <span class="cm">/**** some declaration or so *****/</span>  

<span class="cp">#ifdef __cplusplus</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#endif </span><span class="cm">/* __INCvxWorksh */</span><span class="cp"></span>
</pre></div>
</div>
<div class="section" id="id1">
<h2>extern “C”的含义<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>extern “C” 包含双重含义，从字面上即可得到：首先，被它修饰的目标是“extern”的；其次，被它修饰的目标是“C”的。
被extern “C”限定的函数或变量是extern类型的；</p>
<div class="section" id="extern">
<h3>extern关键字<a class="headerlink" href="#extern" title="永久链接至标题">¶</a></h3>
<p>extern是C/C++语言中表明函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用。
通常，在模块的头文件中对本模块提供给其它模块引用的函数和全局变量以关键字extern声明。例如，如果模块B欲引用该模块A中定义的全局变量和函数时只需包含模块A的头文件即可。这样，模块B中调用模块A中的函数时，在编译阶段，模块B虽然找不到该函数，但是并不会报错；它会在链接阶段中从模块A编译生成的目标代码中找到此函数。
与extern对应的关键字是static，被它修饰的全局变量和函数只能在本模块中使用。因此，一个函数或变量只可能被本模块使用时，其不可能被extern “C”修饰。</p>
</div>
<div class="section" id="extern-c-c">
<h3>被extern “C”修饰的变量和函数是按照C语言方式编译和链接的<a class="headerlink" href="#extern-c-c" title="永久链接至标题">¶</a></h3>
<p>首先看看C++中对类似C的函数是怎样编译的。
作为一种面向对象的语言，C++支持函数重载，而过程式语言C则不支持。函数被C++编译后在符号库中的名字与C语言的不同。例如，假设某个函数的原型为：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span> <span class="p">);</span>
</pre></div>
</div>
<p>该函数被C编译器编译后在符号库中的名字为_foo，而C++编译器则会产生像_foo_int_int之类的名字（不同的编译器可能生成的名字不同，但是都采用了相同的机制，生成的新名字称为“mangled name”）。
<strong>_foo_int_int这样的名字包含了函数名、函数参数数量及类型信息，C++就是靠这种机制来实现函数重载的。</strong> 例如，在C++中，函数void foo( int x, int y )与void foo( int x, float y )编译生成的符号是不相同的，后者为_foo_int_float。
同样地，C++中的变量除支持局部变量外，还支持类成员变量和全局变量。用户所编写程序的类成员变量可能与全局变量同名，我们以”.”来区分。而本质上，编译器在进行编译时，与函数的处理相似，也为类中的变量取了一个独一无二的名字，这个名字与用户程序中同名的全局变量名字不同。</p>
<hr class="docutils" />
<p><em>未加extern “C”声明时的连接方式</em>假设在C++中，模块A的头文件如下：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// 模块A头文件　moduleA.h</span>
<span class="cp">#ifndef MODULE_A_H</span>
<span class="cp">#define MODULE_A_H</span>
<span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span> <span class="p">);</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//在模块B中引用该函数：</span>
<span class="c1">// 模块B实现文件　moduleB.cpp</span>
<span class="cp">#include</span> <span class="cpf">&quot;moduleA.h&quot;</span><span class="cp"></span>
<span class="n">foo</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
</pre></div>
</div>
<p>实际上，在连接阶段，链接器会从模块A生成的目标文件moduleA.obj中寻找_foo_int_int这样的符号！</p>
<p><em>加extern “C”声明后的编译和链接方式</em>加extern “C”声明后，模块A的头文件变为：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// 模块A头文件　moduleA.h</span>
<span class="cp">#ifndef MODULE_A_H</span>
<span class="cp">#define MODULE_A_H</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">int</span> <span class="n">foo</span><span class="p">(</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span> <span class="p">);</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>在模块B的实现文件中仍然调用foo( 2,3 )，其结果是：</p>
<ul class="simple">
<li><p>A编译生成foo的目标代码时，没有对其名字进行特殊处理，采用了C语言的方式；</p></li>
<li><p>链接器在为模块B的目标代码寻找foo(2,3)调用时，寻找的是未经修改的符号名_foo。</p></li>
</ul>
<p>如果在模块A中函数声明了foo为extern “C”类型，而模块B中包含的是extern int foo(int x, int y)，则模块B找不到模块A中的函数；反之亦然。</p>
<p><strong>extern “C”这个声明的真实目的是为了实现C++与C及其它语言的混合编程。</strong></p>
<p>C++代码调用C语言代码、在C++的头文件中使用在C++中引用C语言中的函数和变量，在包含C语言头文件（假设为cExample.h）时，需进行下列处理：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span> <span class="s">&quot;C&quot;</span>
<span class="p">{</span>
<span class="cp">#include</span> <span class="cpf">&quot;cExample.h&quot;</span><span class="cp"></span>
<span class="p">}</span>
</pre></div>
</div>
<p>而在C语言的头文件中，对其外部函数只能指定为extern类型，C语言中不支持extern “C”声明，在.c文件中包含了extern “C”时会出现编译语法错误。</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/* c语言头文件：cExample.h */</span>
<span class="cp">#ifndef C_EXAMPLE_H</span>
<span class="cp">#define C_EXAMPLE_H</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="kt">int</span> <span class="n">y</span><span class="p">);</span>     <span class="c1">//注:写成extern &quot;C&quot; int add(int , int ); 也可以</span>
<span class="cp">#endif</span>

<span class="cm">/* c语言实现文件：cExample.c */</span>
<span class="cp">#include</span> <span class="cpf">&quot;cExample.h&quot;</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">add</span><span class="p">(</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span> <span class="p">)</span>
<span class="p">{</span>
　<span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// c++实现文件，调用add：cppFile.cpp</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span>
<span class="p">{</span>
　<span class="cp">#include</span> <span class="cpf">&quot;cExample.h&quot;        //注：此处不妥，如果这样编译通不过，换成 extern &quot;C&quot; int add(int , int ); 可以通过</span><span class="cp"></span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
　<span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
　<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>如果C++调用一个C语言编写的.DLL时，当包括.DLL的头文件或声明接口函数时，应加extern “C”{}。</strong></p>
<p>在C中引用C++语言中的函数和变量时，C++的头文件需添加extern “C”，但是在C语言中不能直接引用声明了extern “C”的该头文件，应该仅将C文件中将C++中定义的extern “C”函数声明为extern类型</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//C++头文件 cppExample.h</span>
<span class="cp">#ifndef CPP_EXAMPLE_H</span>
<span class="cp">#define CPP_EXAMPLE_H</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">int</span> <span class="n">add</span><span class="p">(</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span> <span class="p">);</span>
<span class="cp">#endif</span>

<span class="c1">//C++实现文件 cppExample.cpp</span>
<span class="cp">#include</span> <span class="cpf">&quot;cppExample.h&quot;</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">add</span><span class="p">(</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span> <span class="p">)</span>
<span class="p">{</span>
　<span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* C实现文件 cFile.c</span>
<span class="cm">/* 这样会编译出错：#include &quot;cExample.h&quot; */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="nf">add</span><span class="p">(</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span> <span class="p">);</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span> <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[]</span> <span class="p">)</span>
<span class="p">{</span>
　<span class="n">add</span><span class="p">(</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">);</span>
　<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<hr class="docutils" />
<p>参考资料：</p>
<blockquote>
<div><p>http://www.jianshu.com/p/5d2eeeb93590</p>
</div></blockquote>
<!-- externC.md ends here --></div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../Code/README.html" class="btn btn-neutral float-right" title="C++ 头文件" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="cast.html" class="btn btn-neutral float-left" title="cast" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Hongyi Wu(吴鸿毅)

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>